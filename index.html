<!DOCTYPE html>
<html>
  <head>
    <title>Technical Introduction to React | BOTS.sh</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">

      /* ----- Fonts ----- */

      @font-face {
        font-family: Karla;
        src: url('fonts/Karla/Karla-Regular.ttf')
      }

      /* ----- Remark overrides ----- */

      .remark-slide-scaler {
        -moz-box-shadow: none;
        -webkit-box-shadow: none;
        box-shadow: none;
      }

      .remark-container,
      .remark-notes-area {
        background: black;
      }

      .remark-slide-content {
        padding: 1em 3em;
      }

      .remark-slide-content h1 {
        font-size: 3.5em;
        line-height: 110%
      }

      .remark-slide-content h2 {
        font-size: 2.5em
      }

      .remark-slide-content.full-code {
        padding: 0
      }
      .full-code pre {
        margin: 0
      }
      .remark-slide>.center pre {
        text-align: left;
      }

      /* ----- BOTS styles ----- */

      .toprightgap {
        position: absolute;
        bottom: 0px;
        right: 0px;
        width: 420px;
        height: 280px;
        background-color: rgba(255, 255, 255, 1);
        box-shadow: 0px 0px 13px rgba(0, 0, 0, 0.6);
        background-image: url(images/one-way.svg);
        background-size: 114%;
        background-position: 50% 50%;
      }

      .slidesLocation{
        position: absolute;
        bottom: 0;
        right: 30px;
      }

      .slidesLocation p a {
        color: white;
        text-shadow: 1px 1px 2px black;
      }

      #backbone1 h1,
      #backbone2 h1,
      #react1 h1 {
        margin: 10px 0;
        font-size: 1.2em;
      }
      #backbone1 p,
      #backbone2 p,
      #react1 p {
        font-size: 1em;
        margin: 5px 0;
      }
      #backbone1 textarea,
      #backbone2 textarea,
      #react1 textarea {
        font-size: 1em;
        height: 1.5em;
        width: 100%;
      }

      .title-page .react-logo {
        width: 250px;
      }
      h1#react-101 {
        margin-top: 40px;
      }

      .title-page .bots-logo-container {
        position: absolute;
        right: 0;
        bottom: 0;
        width: 400px;
        height: 96px;
        padding: 0 50px 50px 0;
      }

      .title-page .bots-logo {
        width: 100%;
      }

      body {
        font-family: Futura, 'Trebuchet MS', Arial, sans-serif;
      }
      h1, h2, h3, p, ol {
        font-weight: normal;
        color: #60545C;
      }

      p, h3 {
        font-size: 1.8em;
      }

      ol {
        font-size: 1.5em;
      }


      a {
        color: #16BECC
      }

      strong {
        color: #1177D5;
      }

      iframe {
        width: 100%;
        height: 100%;
        border: 2px solid #EBEAEA;
      }


      .aside p {
        font-size: 1em;
        color: #ADA7AB

      }

      .context {
        filter: grayscale(0.8) opacity(0.8);
      }

      pre + pre {
        margin-top: 0;
      }

      /* ----- Template styles ----- */

      .brown {
        background: #6F646C
      }
      .brown h1,
      .brown h2,
      .brown p,
      .brown .remark-inline-code {
        color: white
      }

      .blue {
        background: #1177D5;
      }
      .blue h1, .blue h2, .blue h3 {
        color: white
      }
      .blue p {
        color: #a4f0FF;
      }

      .blue a {
        color: white;
      }

      .cover {
        -webkit-background-size: cover !important;
        -moz-background-size: cover !important;
        background-size: cover !important;
        background-position-x: center !important;
        background-position-y: center !important;
        background-repeat: no-repeat !important
      }

      .contain {
        -webkit-background-size: contain !important;
        -moz-background-size: contain !important;
        background-size: contain !important;
        background-position-x: center !important;
        background-position-y: center !important;
        background-repeat: no-repeat !important
      }

      .backbone-image {
        background-image: url('images/backbone.jpg');
        position: absolute;
        top: 0px;
        right: 0px;
        bottom: 0px;
        width: 280px;
      }

      .title-page p {
        font-size: 1.4em;
      }

      .bots-is {
        background-image: url('images/bots-bg.png');
      }

      .hot-reload {
        background-image: url('images/hot.gif');
      }

      .hot-storybook {
        background-image: url('images/hot-storybook.gif');
      }

      .bots-is h1, .bots-is h2, .bots-is h3, .bots-is a {
        color: black;
        text-shadow: 1px 1px 2px white;
      }

      .spaghetti {
        background-image: url('images/off-and-on.gif')
      }

      .spaghetti h2 {
        color: white
      }

      .nightmare {
        background-image: url('images/nightmare.gif')
      }

      .nightmare h2 {
        color: white
      }

      .rebuild {
        background-image: url('images/demolition.gif')
      }

      .rebuild h1 {
        color: white
      }


      .happy-happy-joy-joy {
        background-image: url('images/happy.jpg')
      }

      /* ----- Code ----- */

      .has-code {
        background: #101010;
        padding: 0 2em
      }

      .has-code h1, .has-code h2, .has-code h3, .has-code p {
        color: #EBEAEA
      }

      .has-code .remark-inline-code {
        color: #A4D0DE
      }

      .remark-code, .remark-inline-code {
        font-family: Monaco, "Lucida Console", monospace;
        font-size: 0.8em;
      }
      .remark-inline-code {
        color: #2B497F
      }
      .remark-code-line-highlighted,
      .remark-code-span-highlighted {
        background-color: #333;
      }

      .zoom-code .remark-code {
        font-size: 1.1em;
      }

      .pull-left {
        float: left;
        width: 47%;
      }

      .pull-right {
        float: right;
        width: 47%;
      }

      .comment, .hljs-title {
        color: #969896;
      }

      .hljs-variable, .hljs-attribute, .hljs-tag, .hljs-regexp, .hljs-ruby .constant, .hljs-xml .tag .title, .hljs-xml .pi,
      .hljs-xml .doctype, .hljs-html .doctype, .hljs-css .id, .hljs-css .class, .hljs-css .pseudo {
        color: #cc6666;
      }

      .hljs-number, .hljs-preprocessor, .hljs-built_in, .hljs-literal, .hljs-params, .hljs-constant {
        color: #de935f;
      }


      .hljs-class, .hljs-ruby .class .title, .hljs-css .rules .attribute {
        color: #f0c674;
      }

      .hljs-string, .hljs-value, .hljs-inheritance, .hljs-header, .hljs-ruby .symbol, .hljs-xml .cdata {
        color: #9CDBA5 !important;
      }

      .hljs-css .hexcolor {
        color: #8abeb7;
      }

      .hljs-function, .hljs-python .decorator, .hljs-python .title, .hljs-ruby .function .title, .hljs-ruby .title .keyword,
      .hljs-perl .sub, .hljs-javascript .title, .hljs-coffeescript .title,
      .hljs-default .hljs-subst {
        color: #81a2be;
      }

      .hljs-keyword, .hljs-javascript .function {
        color: #7D8FB0;
        font-weight: normal !important;
      }

      .hljs-default .hljs {
        background: #101010;
        color: #c5c8c6;
        font-family: Menlo, Monaco, Consolas, monospace;
        line-height: 1.5;
        border: 1px solid #ccc;
        padding: 0 10px;
      }


      .hljs-default .hljs-tag,
      .hljs-default .xml .hljs-tag,
      .hljs-default .hljs-tag .hljs-title,
      .hljs-default .xml .hljs-tag .hljs-title {
        color: #66ADC7;
        font-weight: normal !important;
      }

      .hljs-default .hljs-title {
        color: #16BECC;
        font-weight: normal !important;
      }

      code, .remark-code {border: none !important}

      .hljs-default .javascript .xml {
        opacity: 1;
      }

      code .lolight,
      code .lolight * {
        color: #666 !important;
      }

      code .hilight,
      code .hilight * {
        color: #5DC744 !important;
      }
    </style>
    <script src='underscore-min.js'></script>
    <script src='zepto.min.js'></script>
    <script src='backbone-min.js'></script>
    <script src='react.min.js'></script>
    <script src='react-dom.min.js'></script>
  </head>
  <body>
    <script id="source" language="remarkjs"><!--

class: title-page, blue

<div>
<img src='images/react-logo.png' title='React logo' class='react-logo'>
</div>

# Technical Introduction to React

Benjie Gillam

[BOTS.sh](https://BOTS.sh)

<div class='bots-logo-container'>
<img src='images/bots-full-logo.png' title='BOTS logo' class='bots-logo'>
</div>


---

class: bots-is, cover

## BOTS: online web service automation IDE

### Rapidly develop, deploy and debug powerful web integrations.

.slidesLocation[

[benjie.github.io/react-technical-intro/](https://benjie.github.io/react-technical-intro/)
]


---

class: middle

# Content

1. The bad old days
2. React concepts
3. How does React work?
4. But doesn't it have that weird syntax?
5. Class components
6. Props and state
7. Events / controlled components
8. Immutability
9. Hot reloading
10. Let's rebuild everything?
---

class: middle, center, brown

# 1. The bad old days

---

class: middle, has-code

```js
var HomeView = Backbone.View.extend({
  template: _.template('<h1>Hello World!</h1>' +
*   '<p>Random number: <span><%- number %></span> (click for another)</p>' +
    '<textarea>Notes...</textarea>'),

  events: {
*   'click p': 'render'
  },

  randomNumber: function() {
    return Math.floor(Math.random() * 100) + 1;
  },

  render: function() {
*   this.$el.html(this.template({
*     number: this.randomNumber()
*   }));
  }
});
```
<div id="backbone1"></div>


---

class: middle center

## Not so fast!

```js
  template: _.template('<h1>Hello World!</h1>' +
    '<p>Random number: <span><%- number %></span> (click for another)</p>' +
*   '<textarea>Notes...</textarea>'),
  events: {
*   'click p': 'render'
  },
  ...
  render: function() {
*   this.$el.html(this.template({
      number: this.randomNumber()
    }));
  }
```

Calling `render()` overwrites everything, discarding
our `<textarea>` notes. We should only update the random number `<span>`:


---

class: middle, has-code

```js
var HomeView = Backbone.View.extend({
  template: _.template('<h1>Hello World!</h1>' +
*   '<p class="_button">Random number:' +
*     '<span><%- number %></span> (click for another)' +
    '</p>' +
    '<textarea>Notes...</textarea>'),
  events: {
*   'click ._button': 'newNumber'
  },
  randomNumber: function() {
    return Math.floor(Math.random() * 100) + 1;
  },
* newNumber: function(e) {
*   this.$("._button span").html(this.randomNumber());
* },
  render: function() {
    this.$el.html(this.template({
      number: this.randomNumber()
    }));
  }
});
```
<div id="backbone2"></div>

---

class: middle, center

# Great!

Let's just hope no-one changes the template, because each time they do there's a big risk the code will break and the tests fail

---

class: cover, nightmare

---


class: middle, center

# Issues with the old way

Bug-prone manual DOM manipulation

Synchronisation issues: multiple sources of truth

Breaks DRY - changes in one place (template) often require repeating elsewhere (jQuery)

Hard to reason about interactions

## And when it goes wrong...

---


class: middle, center, cover, spaghetti




---

class: middle, center, brown

# 2. React concepts

---

class: middle, has-code


```js
// Remember this?

var HomeView = Backbone.View.extend({
  template: _.template('<h1>Hello World!</h1>' +
    '<p class="_button">Random number:' +
      '<span><%- number %></span> (click for another)' +
    '</p>' +
    '<textarea>Notes...</textarea>'),

  events: {
    'click ._button': 'newNumber'
  },

  randomNumber: function() {
    return Math.floor(Math.random() * 100) + 1;
  },

  newNumber: function(e) {
    this.$("._button span").html(this.randomNumber());
  },

  render: function() {
    this.$el.html(this.template({
      number: this.randomNumber()
    }));
  }
});
```

---

class: has-code

Here it is again, but with React:

```jsx
const randomNumber = () => Math.floor(Math.random() * 100) + 1;
class HomeView extends React.Component {
* state = {randomNumber: randomNumber()};
  newNumber = () => this.setState({randomNumber: randomNumber()});
  render() {
    return (
      <div>
        <h1>Hello World!</h1>
        <p onClick={this.newNumber}>
*         Random number: {this.state.randomNumber} (click for another)
        </p>
        <textarea>Notes...</textarea>
      </div>
    );
  }
}
```

---

class: has-code

Here it is again, but with React:

```jsx
const randomNumber = () => Math.floor(Math.random() * 100) + 1;
class HomeView extends React.Component {
  state = {randomNumber: randomNumber()};
* newNumber = () => this.setState({randomNumber: randomNumber()});
  render() {
    return (
      <div>
        <h1>Hello World!</h1>
*       <p onClick={this.newNumber}>
          Random number: {this.state.randomNumber} (click for another)
        </p>
        <textarea>Notes...</textarea>
      </div>
    );
  }
}
```

---

class: has-code

Here it is again, but with React:

```jsx
const randomNumber = () => Math.floor(Math.random() * 100) + 1;
class HomeView extends React.Component {
  state = {randomNumber: randomNumber()};
* newNumber = () => this.setState({randomNumber: randomNumber()});
  render() {
    return (
      <div>
        <h1>Hello World!</h1>
        <p onClick={this.newNumber}>
*         Random number: {this.state.randomNumber} (click for another)
        </p>
        <textarea>Notes...</textarea>
      </div>
    );
  }
}
```
<div id="react1"></div>

<!--

class: middle, has-code

To be fair, I ought do it in ES5:

```jsx
const randomNumber = function() {return Math.floor(Math.random() * 100) + 1;}

const HomeView = React.createClass({
* getInitialState: function() {
*   return {randomNumber: randomNumber()};
* },

  newNumber: function() {
    this.setState({randomNumber: randomNumber()});
  },

  render: function() {
    return (
      <div>
        <h1>Hello World!</h1>
*       <p onClick={this.newNumber.bind(this)}>
          Random number: {this.state.randomNumber} (click for another)
        </p>
        <textarea>Notes...</textarea>
      </div>
    );
  }
});
```


-->
---

class: center

# **React Concepts**

---

class: center

# React Concepts

**One-way** data flow

<img width="400" src="images/one-way.svg" />

---

class: center

# React Concepts

One-way data flow

Consistency: the **same input** will produce the **same output**


---

class: center

# React Concepts

One-way data flow

Consistency: the same input will produce the same output

Lightweight **reusable** components

---

class: center

# React Concepts

One-way data flow

Consistency: the same input will produce the same output

Lightweight reusable components

Virtual DOM - don&apos;t manipulate the DOM; **simply re-render** with awesome performance

---

class: center

# React Concepts

One-way data flow

Consistency: the same input will produce the same output

Lightweight reusable components

Virtual DOM - don&apos;t manipulate the DOM; simply re-render with awesome performance

.aside[

(There's a lot more to React than this, but this'll serve as headlines for now)
]

---

class: middle, center, cover, happy-happy-joy-joy


---

class: middle, center, brown

# 3. How does React work?


---

class: has-code

# `view = fn(state, props)`

---

class: has-code

# `view = fn(state, props)`

Easy to test: `assertSnapshot(fn({foo: 'bar'}))`

---

class: has-code

# `view = fn(state, props)`

Easy to test

Composable:  
`fn = (props) => fn1(props.foo, fn2(props.bar))`

---

class: has-code

# `view = fn(state, props)`

Easy to test

Composable

Consistent: `assert.deepEqual(fn({foo: 1}), fn({foo: 1}))`

---

class: has-code

# `view = fn(state, props)`

Easy to test

Composable

Consistent

Single source of truth (`props`, `state`)

---

class: has-code

# `view = fn(state, props)`

Easy to test

Composable

Consistent

Single source of truth

## Let's give it a go:

<!-- 
DO NOT USE THIS since it doesn't escape the attributes
const htmlAttrs = (attrs) => Object.keys(attrs || {}).reduce((memo, attr) => `${memo} ${attr}="${attrs[attr]}"`, '')
-->

---

class: has-code

# `view = fn(state, props)`

```js
*const dom = (tag, attrs, ...children) =>
* `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;
```
---

class: has-code

# `view = fn(state, props)`

```js
*const dom = (tag, attrs, ...children) =>
* `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;
```

REPL:
```js
> dom('span', null, 'Hello')
'<span>Hello</span>'
> dom('a', {href: '/foo'}, 'Foo', ' Bar ', 'Baz')
'<a href="/foo">Foo Bar Baz</a>'
```

---

class: has-code

# `view = fn(state, props)`

```js
const dom = (tag, attrs, ...children) =>
  `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;

*const UserName = ({user}) => dom('span', {}, user.name);
```

REPL:
```js
> UserName({user: {name: 'Benjie'}})
'<span>Benjie</span>'
```

---

class: has-code

# `view = fn(state, props)`

```js
const dom = (tag, attrs, ...children) =>
  `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;

const UserName = ({user}) => dom('span', {}, user.name);

*const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', UserName({user}), '!');
```

REPL:
```js
> LoggedInPage({user: {name: 'Benjie'}})
'<h1>Hello <span>Benjie</span>!</h1>'
```

---

class: has-code

# `view = fn(state, props)`

```js
const dom = (tag, attrs, ...children) =>
  `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;

const UserName = ({user}) => dom('span', {}, user.name);

const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', UserName({user}), '!');

*const LoggedOutPage = () => dom('a', {href: '/login'}, 'Please log in!');
```

REPL:
```js
> LoggedOutPage()
'<a href="/login">Please log in!</a>'
```

---

class: has-code

# `view = fn(state, props)`

```js
const dom = (tag, attrs, ...children) =>
  `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;

const UserName = ({user}) => dom('span', {}, user.name);

const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', UserName({user}), '!');

const LoggedOutPage = () => dom('a', {href: '/login'}, 'Please log in!');

*const Page = (props) => (
* props.user ? LoggedInPage(props) : LoggedOutPage(props)
*);
```

```js
> Page({user: null})
'<a href="/login">Please log in!</a>'
> Page({user: {id: 1, name: 'Benjie'}})
'<h1>Hello <span>Benjie</span>!</h1>'
```

---

class: has-code

# `view = fn(state, props)`

So far this is just a way of rendering an **HTML string**:

```js
*const dom = (tag, attrs, ...children) =>
* `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;
```
---

class: has-code

# `view = fn(state, props)`

So far this is just a way of rendering an HTML string; let's instead generate a **virtual DOM** tree:


```js
*const dom = (component, attrs, ...children) => ({
* component: component,
* props: Object.assign({children: children}, attrs)
*});
```

---

class: has-code

# `view = fn(state, props)`

So far this is just a way of rendering an HTML string; let's instead generate a virtual DOM tree:


```js
const dom = (component, attrs, ...children) => ({
  component: component,
  props: Object.assign({children: children}, attrs)
});
```

Now `component` can either be a string (representing a DOM node) or **another function**.

---

class: has-code

# `view = fn(state, props)`

```js
*const dom = (component, attrs, ...children) => ({
* component: component,
* props: Object.assign({children: children}, attrs)
*});

const UserName = ({user}) => dom('span', {}, user.name);

//const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', UserName({user}), '!');
*const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', dom(UserName, {user}), '!');

const LoggedOutPage = () => dom('a', {href: '/login'}, 'Please log in!');

const Page = (props) => (
//props.user ? LoggedInPage(props) : LoggedOutPage(props)
* props.user ? dom(LoggedInPage, props) : dom(LoggedOutPage, props)
);
```
---

class: has-code

# `view = fn(state, props)`

```js
> Page({user: {name: 'Benjie'}})
{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
```
---

class: has-code

# `view = fn(state, props)`

```js
> Page({user: {name: 'Benjie'}})
*{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
```

This is called a '**shallow render**'; and it's one of the things that makes the virtual DOM awesome.
---

class: has-code

# `view = fn(state, props)`

```js
> Page({user: {name: 'Benjie'}})
*{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
```

This is called a 'shallow render'; and it's one of the things that makes the virtual DOM awesome.

For example, you can test the output of `Page` **without invoking** `LoggedInPage`.
---

class: has-code

# `view = fn(state, props)`

```js
> Page({user: {name: 'Benjie'}})
*{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
```

This is called a 'shallow render'; and it's one of the things that makes the virtual DOM awesome.

For example, you can test the output of `Page` without invoking `LoggedInPage`.

It's also a source of massive speed-ups when you have **pure components** (more on this later).

---

class: has-code

# `view = fn(state, props)`

```js
> Page({user: {name: 'Benjie'}})
{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
> LoggedInPage({ children: [], user: { name: 'Benjie' } })
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
*       { component: [Function: UserName],
          props: { children: [], user: { name: 'Benjie' } } },
        '!' ] } }
```
---

class: has-code

# `view = fn(state, props)`

```js
> Page({user: {name: 'Benjie'}})
{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
> LoggedInPage({ children: [], user: { name: 'Benjie' } })
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
        { component: [Function: UserName],
          props: { children: [], user: { name: 'Benjie' } } },
        '!' ] } }
> UserName({ children: [], user: { name: 'Benjie' } })
{ component: 'span', props: { children: [ 'Benjie' ] } }
```
---

class: has-code

.context[

```js
> Page({user: {name: 'Benjie'}})
{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
> LoggedInPage({ children: [], user: { name: 'Benjie' } })
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
        { component: [Function: UserName],
          props: { children: [], user: { name: 'Benjie' } } },
        '!' ] } }
> UserName({ children: [], user: { name: 'Benjie' } })
{ component: 'span', props: { children: [ 'Benjie' ] } }
```
]

A **deep render** produces this virtual DOM tree:

```js
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
        { component: 'span', props: { children: [ 'Benjie' ] } },
        '!' ] } }
```
---

class: has-code

.context[

A deep render produces this virtual DOM tree:

```js
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
        { component: 'span', props: { children: [ 'Benjie' ] } },
        '!' ] } }
```
]

**which translates to this HTML:**

```html
<h1>Hello <span>Benjie</span>!</h1>
```


---

class: has-code

# `view = fn(state, props)`

Now imagine I change the params, so  
instead of `Page({user: {name: 'Benjie'}})`,  
we do `Page({user: {name: 'Jof'}})`

---

class: has-code

# `view = fn(state, props)`

```js
// Before
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
*       { component: 'span', props: { children: [ 'Benjie' ] } },
        '!' ] } }

// After
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
*       { component: 'span', props: { children: [ 'Jof' ] } },
        '!' ] } }
```

---

class: has-code

# `view = fn(state, props)`

```js
// Before
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
*       { component: 'span', props: { children: [ 'Benjie' ] } },
        '!' ] } }

// After
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
*       { component: 'span', props: { children: [ 'Jof' ] } },
        '!' ] } }
```

This is where React's magic comes in.

---

class: has-code

# `view = fn(state, props)`

Instead of naively re-rendering everything, React **diffs the Virtual
DOM** and executes only the changes necessary to transform the old
DOM state into the new one.

---

class: has-code

# `view = fn(state, props)`

Instead of naively re-rendering everything, React diffs the Virtual
DOM and executes only the changes necessary to transform the old
DOM state into the new one.

And what's more, it does it **without reading the browser DOM** - so no
read-write-read-write DOM re-layout bottlenecks!

---

class: has-code

# `view = fn(state, props)`

Instead of naively re-rendering everything, React diffs the Virtual
DOM and executes only the changes necessary to transform the old
DOM state into the new one.

And what's more, it does it **without reading the browser DOM** - so no
read-write-read-write DOM re-layout bottlenecks!

.aside[

(See [Reconciliation](http://facebook.github.io/react/docs/reconciliation.html) in their docs for how they changed an O(n<sup>3</sup>) problem to O(n))
]

---

class: has-code

# `view = fn(state, props)`

And **this isn't limited to HTML** and the browser! Facebook have split React
into it's core logic (React) and on top of that you can build a renderer for
other things.

---

class: has-code

# `view = fn(state, props)`

And this isn't limited to HTML and the browser! Facebook have split React
into it's core logic (React) and on top of that you can build a renderer for
other things.

`react-dom` - **HTML rendering** (server and browser)

---

class: has-code

# `view = fn(state, props)`

And this isn't limited to HTML and the browser! Facebook have split React
into it's core logic (React) and on top of that you can build a renderer for
other things.

`react-dom` - HTML rendering (server and browser)

`react-native` - **iOS and Android** apps using **native views**

---

class: middle, center, brown

# 4. But doesn't it have that weird syntax?

---

class: has-code

# New Syntax

Instead of writing `dom(component, attributes, ...children)` all over the place, we can **extend JavaScript's syntax** to be more convenient.

---

class: has-code

# New Syntax

Instead of writing `dom(component, attributes, ...children)` all over the place, we can extend JavaScript's syntax to be more convenient.

We call this new syntax **JSX**.


---

class: has-code

# New Syntax

Instead of writing `dom(component, attributes, ...children)` all over the place, we can extend JavaScript's syntax to be more convenient.

We call this new syntax JSX.

Using JSX is **optional** - it's just syntactic sugar.

---

class: has-code

# New Syntax

Instead of writing `dom(component, attributes, ...children)` all over the place, we can extend JavaScript's syntax to be more convenient.

We call this new syntax JSX.

Using JSX is optional - it's just syntactic sugar.

## Let's take a look...

---

class: has-code

# JSX

```jsx
//const UserName = ({user}) => dom('span', {}, user.name);
* const UserName = ({user}) => (<span>{user.name}</span>);
```

---

class: has-code

# JSX

```jsx
  const UserName = ({user}) => (<span>{user.name}</span>);
```
```jsx
//const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', UserName({user}), '!');
* const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```
---

class: has-code

# JSX

```jsx
  const UserName = ({user}) => (<span>{user.name}</span>);
```
```jsx
  const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```
```jsx
//const LoggedOutPage = () => dom('a', {href: '/login'}, 'Please log in!');
* const LoggedOutPage = () => (<a href="/login">Please log in!</a>);
```

---

class: has-code

# JSX

```jsx
  const UserName = ({user}) => (<span>{user.name}</span>);
```
```jsx
  const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```
```jsx
  const LoggedOutPage = () => (<a href="/login">Please log in!</a>);
```
```jsx
//const Page = (props) => (
//  props.user
//  ? LoggedInPage(props)
//  : LoggedOutPage(props)
//);
* const Page = (props) => (
*   props.user
*   ? (<LoggedInPage user={props.user} />)
*   : (<LoggedOutPage />)
* );
```

---

class: has-code

# JSX

```jsx
  const UserName = ({user}) => (<span>{user.name}</span>);
```
```jsx
  const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```
```jsx
  const LoggedOutPage = () => (<a href="/login">Please log in!</a>);
```
```jsx
  const Page = (props) => (
    props.user
    ? (<LoggedInPage user={props.user} />)
    : (<LoggedOutPage />)
  );
```

---

class: has-code

# JSX

```jsx
  const UserName = ({user}) => (<span>{user.name}</span>);
```
```jsx
  const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```
```jsx
  const LoggedOutPage = () => (<a href="/login">Please log in!</a>);
```
```jsx
  const Page = (props) => (
    props.user
    ? (<LoggedInPage user={props.user} />)
    : (<LoggedOutPage />)
  );
```

.aside[

React actually uses `React.createElement(...)` where we used `dom(...)`, but you can see how the JSX syntax compiles down to simple JS.
]
---

class: normal

## JSX vs HTML oddities:

Case matters: `onClick` not `onclick`

Some attributes are renamed to avoid clashes:  
`class` → `className`; `for` → `htmlFor`

You have to close tags (think XHTML)

Be explicit: `<table>`**`<tbody>`**`<tr><td>...`

---

class: middle, center, brown

# 5. Class components
---

class: has-code

## Class Components

So far we've dealt with **functional components**.

---

class: has-code

## Class Components

So far we've dealt with functional components.

If your component needs **state** or **lifecycle methods** then it needs to be a **class component**.
---

class: has-code

## Class Components

So far we've dealt with functional components.

If your component needs **state** or **lifecycle methods** then it needs to be a **class component**.


.aside[

*Or a HOC (higher order component); but let's skip over that for now...
]

---

class: has-code

## Class Components

So far we've dealt with functional components.

If your component needs **state** or **lifecycle methods** then it needs to be a **class component**.

```jsx
// Functional
*const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```

---

class: has-code

## Class Components

So far we've dealt with functional components.

If your component needs **state** or **lifecycle methods** then it needs to be a **class component**.

```jsx
// Functional
const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```
```jsx
// Class
class LoggedInPage extends React.Component {
  render() {
    const {user} = this.props;
    return (<h1>Hello <UserName user={user} />!</h1>);
  }
}
```
---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
* state = {currentDate: new Date()};

  updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
    this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
    const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
    return (
      <span>
        {seconds} seconds remain until {this.props.date.toISOString()}
      </span>
    );
  }
}
```
---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
  state = {currentDate: new Date()};

  updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
    this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
*   const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
*   return (
*     <span>
*       {seconds} seconds remain until {this.props.date.toISOString()}
*     </span>
*   );
  }
}
```
---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
  state = {currentDate: new Date()};

  updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
*   this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
    const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
    return (
      <span>
        {seconds} seconds remain until {this.props.date.toISOString()}
      </span>
    );
  }
}
```
---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
  state = {currentDate: new Date()};

* updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
    this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
    const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
    return (
      <span>
        {seconds} seconds remain until {this.props.date.toISOString()}
      </span>
    );
  }
}
```
---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
  state = {currentDate: new Date()};

  updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
    this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
*   const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
*   return (
*     <span>
*       {seconds} seconds remain until {this.props.date.toISOString()}
*     </span>
*   );
  }
}
```
---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
  state = {currentDate: new Date()};

  updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
    this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
*   clearInterval(this.timer);
  }

  render() {
    const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
    return (
      <span>
        {seconds} seconds remain until {this.props.date.toISOString()}
      </span>
    );
  }
}
```
---

class: middle, center, brown

# 6. Props and state

---

class: normal

**Props** are used to pass **external data** to components.

---

class: normal

**Props** are used to pass **external data** to components.

```jsx
<UserCard
* user={{
    fullName: 'Benjie Gillam',
    id: 1,
    avatarUrl: 'https://s.gravatar.com/avatar/9b0431915359b131d88667c6b4078dc7'
  }}
* size='small'
/>
```

---

class: normal

**Props** are used to pass **external data** to components.

```jsx
<UserCard
  user={{
    fullName: 'Benjie Gillam',
    id: 1,
    avatarUrl: 'https://s.gravatar.com/avatar/9b0431915359b131d88667c6b4078dc7'
  }}
  size='small'
/>
```
```jsx
*// Components can then pass (optionally modified) props on to sub-components
function UserCard({user, size}) {
  return (
    <div className='UserCard'>
*     <Avatar url={user.avatarUrl} small={size === 'small'} />
*     <UserName user={user}></UserName>
    </div>
  );
}
```


---

class: normal

## **State**

---

class: normal

## State

It's generally **best to be state-less**; state makes bugs a lot harder to track down.

---

class: normal

## State

It's generally best to be state-less; state makes bugs a lot harder to track down.

**Local data** (per-component) is stored to `this.state`, e.g. `this.state.firstName`.

---

class: normal

## State

It's generally best to be state-less; state makes bugs a lot harder to track down.

Local data (per-component) is stored to `this.state`, e.g. `this.state.firstName`.

When you change `this.state` (by calling `this.setState`), React **automatically re-renders**.


---

class: middle, center, brown

# 7. Events / controlled components

---

class: middle, center

**Events** are how you **manipulate your state**

<div style='visibility: hidden'>
<img width="80%" src="images/one-way.svg" />
</div>

---

class: middle, center

**Events** are how you **manipulate your state**

<div>
<img width="80%" src="images/one-way.svg" />
</div>

---

class: has-code

<div class='toprightgap'></div>

```jsx
*const TodoItem = ({text, onDeleteClick}) => (
  <div className='TodoItem'>
    <div className='TodoItem__text'>{text}</div>
*   <div className='TodoItem__delete' onClick={onDeleteClick}>X</div>
  </div>
);
```

---

class: has-code

<div class='toprightgap'></div>

```jsx
const TodoItem = ({text, onDeleteClick}) => (
  <div className='TodoItem'>
    <div className='TodoItem__text'>{text}</div>
    <div className='TodoItem__delete' onClick={onDeleteClick}>X</div>
  </div>
);
*const TodoList = ({items, onDeleteItem}) => (
  <div className='TodoList'>
    {items.map(
      ({text, id}) => (
        <TodoItem
          key={id}
          text={text}
*         onDeleteClick={() => onDeleteItem(id)}
        />
      )
    )}
  </div>
);
```
---

class: has-code

<div class='toprightgap'></div>
```jsx
*const TodoList = ({items, onDeleteItem}) => ( ... );
class TodoApp extends React.Component {
  state = {
    items: [
      {id: 1, text: 'Convert to React'},
      {id: 2, text: 'Make Awesome Stuff'}]};

* handleDelete = (id) => {
*   this.setState({items: this.state.items.filter(item => item.id !== id)});
* }

  render() {
    return (
      <div className='TodoApp'>
*       <TodoList items={this.state.items} onDeleteItem={this.handleDelete} />
      </div>
    );
  }
}
```
---

class: middle, center

## Controlled Components

To avoid storing implicit state in the DOM.
---

class: has-code

```jsx
const TodoList = ({items, onDeleteItem}) => ( ... );
class TodoApp extends React.Component {
  state = {
*   nextItemText: '',
    items: [
      {id: 1, text: 'Convert to React'},
      {id: 2, text: 'Make Awesome Stuff'}]};

  handleDelete = (id) => {
    this.setState({items: this.state.items.filter(item => item.id !== id)});
  }

  render() {
    return (
      <div className='TodoApp'>
        <TodoList items={this.state.items} onDeleteItem={this.handleDelete} />
*       <input
*         value={this.state.nextItemText}
*         onChange={e => this.setState({nextItemText: e.target.value})}
*       />
      </div>
    );
  }
}
```
---

class: has-code

```jsx
class TodoApp extends React.Component {
  state = {
    nextItemText: '',
    items: [
      {id: 1, text: 'Convert to React'},
      {id: 2, text: 'Make Awesome Stuff'}]};
  handleDelete = (id) => {...}
* handleKeyPress = (e) => {
*   if (e.key === 'Enter') {
*     this.setState({
*       items: [].concat(this.state.items,
*                        {id: newId(), text: this.state.nextItemText}),
*       nextItemText: '',
*     });
*   }
* },
  render() {
    return (
      <div className='TodoApp'>
        <TodoList items={this.state.items} onDeleteItem={this.handleDelete} />
        <input
*         onKeyPress={this.handleKeyPress}
          value={this.state.nextItemText}
          onChange={e => this.setState({nextItemText: e.target.value})}
        />
      </div>
    );
  }
}
```
---

class: middle, center, brown

# 8. Immutability

---


## Immutability

A component that only uses immutable data is called a **pure component**.

---


## Immutability

A component that only uses immutable data is called a pure component.

By only using immutable data, we can **very quickly** check which props have changed.

---


## Immutability

A component that only uses immutable data is called a pure component.

By only using immutable data, we can very quickly check which props have changed.

If none have changed we can **bypass rendering** and reuse the last virtual DOM subtree.

---


## Immutability

A component that only uses immutable data is called a pure component.

By only using immutable data, we can very quickly check which props have changed.

If none have changed we can bypass rendering and reuse the last virtual DOM subtree.

This can happen for **every component**!

<!--

class: has-code

## Immutability

```jsx
class FibonacciNumber extends React.PureComponent {
  fibonacci(n) {
    if (n < 1) return 0;
    if (n == 1) return 1;
    return this.fibonacci(n - 1) + this.fibonacci(n - 2);
  }
  render() {
    return (
      <span>{this.fibonacci(this.props.n)}
    );
  }
}
```
-->
---

class: middle, center, brown

# 9. Hot reloading
---

class: hot-reload, contain

---

class: hot-storybook, contain

---

class: middle, center, brown

# 10. AWESOME!

## So should we rebuild everything in React?

<p style="visibility: hidden">No, not necessarily</p>

---

class: middle, center, brown

# 10. AWESOME!

## So should we rebuild everything in React?

No, not necessarily

---

class: center

# **React is a library**

---

class: center

# React is a library

You can **embed React** into other things.

---

class: center

# React is a library

You can embed React into other things.

You can **embed other things into React**.

---

class: center

# React is a library

You can embed React into other things.

You can embed other things into React.

You can **migrate to React bit-by-bit** without having to rebuild everything!

---

class: center

# React is a library

You can embed React into other things.

You can embed other things into React.

You can migrate to React bit-by-bit without having to rebuild everything!

The React API is really small, so very **quick to learn**.

---
class: middle, center, brown

# Recap

---

class: normal

## Recap

One-way data flow

Virtual DOM

Reusable components

Good habits, no unnecessary re-layout

Can migrate bit-by-bit

Small API


---

class: normal, center, middle

## SO YOU'RE CONVERTED!

Where to next?

https://facebook.github.io/react/docs

`npm install create-react-app -g`

https://egghead.io/technologies/react

https://getstorybook.io/



---

class: bots-is, cover

# Thank you!

### If you like playing with new tech that'll make you more productive; we're looking for alpha testers!
### benjie at [BOTS.sh](https://BOTS.sh)

.slidesLocation[

[benjie.github.io/react-technical-intro/](https://benjie.github.io/react-technical-intro/)
]

--></script>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        source: (document.getElementById("source").innerHTML).replace(/^<!--|-->$/g, ""),
        slideNumberFormat: function (current, total) { return null },
        ratio: '4:3',
        highlightLines: true,
        highlightSpans: false // We need ES6 backticks
      });
      var HomeView = Backbone.View.extend({
        template: _.template('<h1>Hello World!</h1>' +
          '<p>Random number: <span><%- number %></span> (click for another)</p>' +
          '<textarea>Notes...</textarea>'),

        events: {
          'click p': 'render',
          'keydown textarea': 'stopPropagation',
          'keypress textarea': 'stopPropagation',
        },

        stopPropagation: function(e) {
          e.stopPropagation();
        },

        randomNumber: function() {
          return Math.floor(Math.random() * 100) + 1;
        },

        render: function() {
          this.$el.html(this.template({
            number: this.randomNumber()
          }));
        }
      });
      var HomeView2 = Backbone.View.extend({
        template: _.template('<h1>Hello World!</h1>' +
          '<p class="_button">Random number:' +
            '<span><%- number %></span> (click for another)' +
          '</p>' +
          '<textarea>Notes...</textarea>'),
        events: {
          'click ._button': 'newNumber',
          'keydown textarea': 'stopPropagation',
          'keypress textarea': 'stopPropagation',
        },
        stopPropagation: function(e) {
          e.stopPropagation();
        },
        randomNumber: function() {
          return Math.floor(Math.random() * 100) + 1;
        },
        newNumber: function(e) {
          this.$("._button span").html(this.randomNumber());
        },
        render: function() {
          this.$el.html(this.template({
            number: this.randomNumber()
          }));
        }
      });
      const backbone1 = new HomeView();
      $("#backbone1").append(backbone1.el);
      backbone1.render();
      const backbone2 = new HomeView2();
      $("#backbone2").append(backbone2.el);
      backbone2.render();
      const randomNumber = function() {return Math.floor(Math.random() * 100) + 1;}

      const stopPropagation = (e) => e.stopPropagation();

      const HomeView3 = React.createClass({
        getInitialState: function() {
          return {randomNumber: randomNumber()};
        },

        newNumber: function() {
          this.setState({randomNumber: randomNumber()});
        },

        render: function() {
          return (
            React.createElement('div', null,
              React.createElement('h1', null, 'Hello World!'),
              React.createElement('p', {onClick: this.newNumber.bind(this)},
                'Random number: ', this.state.randomNumber, ' (click for another)'
              ),
              React.createElement('textarea', {onKeyPress: stopPropagation, onKeyDown: stopPropagation}, 'Notes...')
            )
          );
        }
      });
      ReactDOM.render(React.createElement(HomeView3), $("#react1")[0]);
    </script>
  </body>
</html>
