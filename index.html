<!DOCTYPE html>
<html>
  <head>
    <title>Technical Introduction to React | BOTS.sh</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="styles.css" />
    <script src='underscore-min.js'></script>
    <script src='zepto.min.js'></script>
    <script src='backbone-min.js'></script>
    <script src='react.min.js'></script>
    <script src='react-dom.min.js'></script>
  </head>
  <body>
    <script id="source" language="remarkjs"><!--

class: title-page, blue

<div>
<img src='images/react-logo.png' title='React logo' class='react-logo'>
</div>

# Technical Introduction to React

Benjie Gillam

Freelancer,  
[PostGraphQL](https://github.com/postgraphql/postgraphql) maintaner

<div class='postgraphql-logo-container'>
<img src='images/postgraphql-logo.png' title='PostGraphQL logo' class='postgraphql-logo'>
</div>
.slidesLocation[

[benjie.github.io/react-technical-intro/](https://benjie.github.io/react-technical-intro/)
]

???

Please note the URL at the bottom, so don't worry about jotting down code. Of
course if you want to follow along on your phone or laptop, please do!

---

class: postgraphql-is, cover

<img src='images/postgraphql-full-logo.png' title='PostGraphQL logo' class='postgraphql-logo' style="width: 100%">

GraphQL is a powerful alternative to REST where the client requests (and receives) exactly the data it wants and no more.

PostGraphQL leverages PostgreSQL's powerful security features such as Row Level Security to automatically build an entire GraphQL API from the database you already have.

.slidesLocation[

[benjie.github.io/react-technical-intro/](https://benjie.github.io/react-technical-intro/)
]

???

A quick plug before we get started...

A tool to help you explore and understand the APIs and webhooks for the
webservices you use every day, such as BitBucket, GitHub, Trello, Slack, ...

Using BOTS you can build and deploy powerful integrations in minutes


---

class: middle

## Content

1. The bad old days
2. React concepts
3. How does React work?
4. But doesn't it have that weird syntax?
5. Class vs functional components
6. Props and state
7. Events / controlled components
8. Immutability
9. Hot reloading
10. Let's rebuild everything?

.slidesLocation.onWhite[

[benjie.github.io/react-technical-intro/](https://benjie.github.io/react-technical-intro/)
]

???

There's a lot to cover.

This is a technical introduction, so it's more about how React works than how
to use it.

---

class: middle, center, brown

# 1. The bad old days

---

class: has-code

```js
var HomeView = Backbone.View.extend({
  template: _.template('<h1>Hello World!</h1>' +
    '<p>Random number: <span><%- number %></span> (click for another)</p>' +
    '<textarea>Notes...</textarea>'),

  events: {
*   'click p': 'render'
  },

  randomNumber: function() {
    return Math.floor(Math.random() * 100) + 1;
  },

* render: function() {
*   this.$el.html(this.template({
*     number: this.randomNumber()
    }));
  }
});

```

???

Here's a Backbone View.

1. Renders template
2. You click the p; it re-renders the template

---

class: has-code

```js
var HomeView = Backbone.View.extend({
  template: _.template('<h1>Hello World!</h1>' +
    '<p>Random number: <span><%- number %></span> (click for another)</p>' +
*   '<textarea>Notes...</textarea>'),

  events: {
    'click p': 'render'
  },

  randomNumber: function() {
    return Math.floor(Math.random() * 100) + 1;
  },

  render: function() {
*   this.$el.html(this.template({
      number: this.randomNumber()
    }));
  }
});
```
<div id="backbone1"></div>

???

&lt;Frustrated sigh as our notes are lost&gt;

---

class: has-code

```js
var HomeView = Backbone.View.extend({
  template: _.template('<h1>Hello World!</h1>' +
    '<p>Random number: <span><%- number %></span> (click for another)</p>' +
*   '<textarea>Notes...</textarea>'),

  events: {
    'click p': 'render'
  },

  randomNumber: function() {
    return Math.floor(Math.random() * 100) + 1;
  },

  render: function() {
*   this.$el.html(this.template({
      number: this.randomNumber()
    }));
  }
});
```

Calling `render()` overwrites everything, discarding
our `<textarea>` notes. We should only update the random number `<span>`:


---

class: middle, has-code

```js
var HomeView = Backbone.View.extend({
  template: _.template('<h1>Hello World!</h1>' +
*   '<p class="_button">Random number: ' +
*     '<span><%- number %></span> (click for another)' +
    '</p>' +
    '<textarea>Notes...</textarea>'),
  events: {
*   'click ._button': 'newNumber'
  },
  randomNumber: function() {
    return Math.floor(Math.random() * 100) + 1;
  },
* newNumber: function(e) {
*   this.$("._button span").html(this.randomNumber());
* },
  render: function() {
    this.$el.html(this.template({
      number: this.randomNumber()
    }));
  }
});
```
<div id="backbone2"></div>

???

Okay so we can slap classes all over the place, and carefully only update the
parts that are supposed to change; but...

---


class: center

# Issues with the old way

Poorly performing manual DOM manipulation

???

Maintenance burden

--

Code everything twice - once in the template, and once again updating the DOM (jQuery)

--

Not sure if it's safe to edit a template

--

Hard to reason about component interactions

---


class: center

# Issues with the old way

Poorly performing manual DOM manipulation

Code everything twice - once in the template, and once again updating the DOM (jQuery)

Not sure if it's safe to edit a template

Hard to reason about component interactions

## And when it goes wrong... .f5[F5]

---

class: middle, center, cover, spaghetti

---

class: middle, center, brown

# 2. React concepts

???

So how does React solve this?

---

class: middle, has-code


```js
// Remember this?

var HomeView = Backbone.View.extend({
  template: _.template('<h1>Hello World!</h1>' +
    '<p class="_button">Random number:' +
      '<span><%- number %></span> (click for another)' +
    '</p>' +
    '<textarea>Notes...</textarea>'),

  events: {
    'click ._button': 'newNumber'
  },

  randomNumber: function() {
    return Math.floor(Math.random() * 100) + 1;
  },

  newNumber: function(e) {
    this.$("._button span").html(this.randomNumber());
  },

  render: function() {
    this.$el.html(this.template({
      number: this.randomNumber()
    }));
  }
});
```

???

Remember this Backbone view we were looking at just now?

---

class: has-code

Here it is again, but with React:

```jsx
const randomNumber = () => Math.floor(Math.random() * 100) + 1;
class HomeView extends React.Component {
* state = {randomNumber: randomNumber()};
  newNumber = () => this.setState({randomNumber: randomNumber()});
  render() {
    return (
      <div>
        <h1>Hello World!</h1>
        <p onClick={this.newNumber}>
*         Random number: {this.state.randomNumber} (click for another)
        </p>
        <textarea>Notes...</textarea>
      </div>
    );
  }
}
```

???

1st we generate the random number and store it onto our state.

Then we render.

---

class: has-code

Here it is again, but with React:

```jsx
const randomNumber = () => Math.floor(Math.random() * 100) + 1;
class HomeView extends React.Component {
  state = {randomNumber: randomNumber()};
* newNumber = () => this.setState({randomNumber: randomNumber()});
  render() {
    return (
      <div>
        <h1>Hello World!</h1>
*       <p onClick={this.newNumber}>
          Random number: {this.state.randomNumber} (click for another)
        </p>
        <textarea>Notes...</textarea>
      </div>
    );
  }
}
```

???

When someone clicks the p tag, the event listener is called, and it updates the state.

Don't worry, that's not a real inline event listener - React abstracts that
all away for us in a virtual DOM.

---

class: has-code

Here it is again, but with React:

```jsx
const randomNumber = () => Math.floor(Math.random() * 100) + 1;
class HomeView extends React.Component {
  state = {randomNumber: randomNumber()};
* newNumber = () => this.setState({randomNumber: randomNumber()});
  render() {
    return (
      <div>
        <h1>Hello World!</h1>
        <p onClick={this.newNumber}>
*         Random number: {this.state.randomNumber} (click for another)
        </p>
        <textarea>Notes...</textarea>
      </div>
    );
  }
}
```

???

As soon as the state is updated, React automatically re-renders its virtual
DOM for us; but the only thing that actually changed was the number, so
that's the only bit React updates.
---

class: has-code

Here it is again, but with React:

```jsx
const randomNumber = () => Math.floor(Math.random() * 100) + 1;
class HomeView extends React.Component {
  state = {randomNumber: randomNumber()};
  newNumber = () => this.setState({randomNumber: randomNumber()});
  render() {
    return (
      <div>
        <h1>Hello World!</h1>
        <p onClick={this.newNumber}>
          Random number: {this.state.randomNumber} (click for another)
        </p>
        <textarea>Notes...</textarea>
      </div>
    );
  }
}
```

```js
*const root = document.getElementById('root');
*ReactDOM.render(<HomeView />, root);
```

???

To render it into the browser, we just need these two lines of code



---

class: has-code

Here it is again, but with React:

```jsx
const randomNumber = () => Math.floor(Math.random() * 100) + 1;
class HomeView extends React.Component {
  state = {randomNumber: randomNumber()};
  newNumber = () => this.setState({randomNumber: randomNumber()});
  render() {
    return (
      <div>
        <h1>Hello World!</h1>
        <p onClick={this.newNumber}>
          Random number: {this.state.randomNumber} (click for another)
        </p>
        <textarea>Notes...</textarea>
      </div>
    );
  }
}
```
<div id="react1"></div>

???

And here it is; you can check the source on GitHub to see I've not done any
smoke and mirrors!

<!--

class: middle, has-code

To be fair, I ought do it in ES5:

```jsx
const randomNumber = function() {return Math.floor(Math.random() * 100) + 1;}

const HomeView = React.createClass({
* getInitialState: function() {
*   return {randomNumber: randomNumber()};
* },

  newNumber: function() {
    this.setState({randomNumber: randomNumber()});
  },

  render: function() {
    return (
      <div>
        <h1>Hello World!</h1>
*       <p onClick={this.newNumber.bind(this)}>
          Random number: {this.state.randomNumber} (click for another)
        </p>
        <textarea>Notes...</textarea>
      </div>
    );
  }
});
```


-->
---

class: center

# **React Concepts**

---

class: center

# React Concepts

**One-way** data flow

<img width="400" src="images/one-way.svg" />

???

Data flows down the tree, and events flow back up.

Never fetch data from a parent.

Never send an event to a child.

---

class: center

# React Concepts

One-way data flow

Consistency: the **same input** should produce the **same output**


---

class: center

# React Concepts

One-way data flow

Consistency: the same input should produce the same output

**Lightweight** reusable components

---

class: center

# React Concepts

One-way data flow

Consistency: the same input should produce the same output

Lightweight reusable components

Don't mutate, **simply re-render**  
(virtual DOM → crazy fast)

???

Before single page apps were really a thing, we'd take data on the server
side, pipe it through a template, and render that to the client. Simple.

React make's it lightning fast (60fps) to do that on the client side.

---

class: center

# React Concepts

One-way data flow

Consistency: the same input should produce the same output

Lightweight reusable components

Don't mutate, simply re-render  
(virtual DOM → crazy fast)

.aside[

(There's a lot more to React than this, but this'll serve as headlines for now)
]

---

class: middle, center, brown

# 3. How does React work?


---

class: has-code

# `view = fn(props, state)`

???

It all comes down to this.

Your view is a function of your initial data from the server (props) and
state that builds up as you use it (e.g. opening/closing modals).

---

class: has-code

# `view = fn(props, state)`

Consistent / easy to test  
`assert.deepEqual(fn({foo: 1}), fn({foo: 1}))`

???

Consistency: the **same input** should produce the **same output**

--

Composable  
`fn = (props) => fn1(fn2)(props)`

???

Combine components in powerful ways without subclassing (remember Neil's
talk, So SOLID Fu, this is the **Open-Closed principle**)

--

Easy to reproduce issues  
`fn(badState)`

???

Copy the bad props and state and reproduce locally, harks back to
**consistency** again.

--

## Let's give it a go:

???

**THIS GETS TECHNICAL; I'll let you know when to tune back in**

<!-- 
DO NOT USE THIS since it doesn't escape the attributes
const htmlAttrs = (attrs) => Object.keys(attrs || {}).reduce((memo, attr) => `${memo} ${attr}="${attrs[attr]}"`, '')
-->

---

class: has-code

# `view = fn(props, state)`

```js
*const dom = (tag, attrs, ...children) =>
* `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;
```

???

Here's a function that generates an HTML string.

---

class: has-code

# `view = fn(props, state)`

```js
*const dom = (tag, attrs, ...children) =>
* `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;
```

.aside[

Note `...children` is an ES2015 feature called **rest parameters** that catches all additional arguments and puts them into an array for you.
]
---

class: has-code

# `view = fn(props, state)`

```js
*const dom = (tag, attrs, ...children) =>
* `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;
```

REPL:
```js
> dom('span', null, 'Hello')
'<span>Hello</span>'
> dom('a', {href: '/foo'}, 'Foo', ' Bar ', 'Baz')
'<a href="/foo">Foo Bar Baz</a>'
```

???

I've ran these examples in my REPL so you can see what the functions do.

---

class: has-code

# `view = fn(props, state)`

```js
const dom = (tag, attrs, ...children) =>
  `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;

*const UserName = ({user}) => dom('span', {}, user.name);
```

REPL:
```js
> UserName({user: {name: 'Benjie'}})
'<span>Benjie</span>'
```

---

class: has-code

# `view = fn(props, state)`

```js
const dom = (tag, attrs, ...children) =>
  `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;

const UserName = ({user}) => dom('span', {}, user.name);

*const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', UserName({user}), '!');
```

REPL:
```js
> LoggedInPage({user: {name: 'Benjie'}})
'<h1>Hello <span>Benjie</span>!</h1>'
```

---

class: has-code

# `view = fn(props, state)`

```js
const dom = (tag, attrs, ...children) =>
  `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;

const UserName = ({user}) => dom('span', {}, user.name);

const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', UserName({user}), '!');

*const LoggedOutPage = () => dom('a', {href: '/login'}, 'Please log in!');
```

REPL:
```js
> LoggedOutPage()
'<a href="/login">Please log in!</a>'
```

???

Similar to **UserName**

---

class: has-code

# `view = fn(props, state)`

```js
const dom = (tag, attrs, ...children) =>
  `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;

const UserName = ({user}) => dom('span', {}, user.name);

const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', UserName({user}), '!');

const LoggedOutPage = () => dom('a', {href: '/login'}, 'Please log in!');

*const Page = (props) => (
* props.user ? LoggedInPage(props) : LoggedOutPage(props)
*);
```

```js
> Page({user: null})
'<a href="/login">Please log in!</a>'
> Page({user: {id: 1, name: 'Benjie'}})
'<h1>Hello <span>Benjie</span>!</h1>'
```

---

class: has-code

# `view = fn(props, state)`

So far this is just a way of rendering an **HTML string**:

```js
const dom = (tag, attrs, ...children) =>
* `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;
```
---

class: has-code

# `view = fn(props, state)`

So far this is just a way of rendering an HTML string; let's instead generate a **virtual DOM** tree:


```js
const dom = (tag, attrs, ...children) => ({
* component: tag,
* props: Object.assign({children: children}, attrs)
});
```

???

... and in fact, there's no need for `tag` to be a string any more...

... so let's rename it to `component`...

---

class: has-code

# `view = fn(props, state)`

So far this is just a way of rendering an HTML string; let's instead generate a virtual DOM tree:


```js
const dom = (component, attrs, ...children) => ({
  component: component,
  props: Object.assign({children: children}, attrs)
});
```

Now `component` can either be a string (representing a DOM node) or **another function**.

---

class: has-code

# `view = fn(props, state)`

```js
//const dom = (tag, attrs, ...children) =>
//  `<${tag}${htmlAttrs(attrs)}>${children.join('')}</${tag}>`;
*const dom = (component, attrs, ...children) => ({
* component: component,
* props: Object.assign({children: children}, attrs)
*});

const UserName = ({user}) => dom('span', {}, user.name);

//const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', UserName({user}), '!');
*const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', dom(UserName, {user}), '!')

const LoggedOutPage = () => dom('a', {href: '/login'}, 'Please log in!');

const Page = (props) => (
//props.user ? LoggedInPage(props) : LoggedOutPage(props)
* props.user ? dom(LoggedInPage, props) : dom(LoggedOutPage, props)
);
```

???

Note **UserName** and **LoggedOutPage** are unchanged.

... Okay, so lets have a go at rendering these again

---

class: has-code

# `view = fn(props, state)`

```js
> Page({user: {name: 'Benjie'}})
{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
```

???

Well... this doesn't look like it has the whole page rendered...
---

class: has-code

# `view = fn(props, state)`

```js
> Page({user: {name: 'Benjie'}})
*{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
```

This is called a '**shallow render**'; and it's one of the things that makes the virtual DOM awesome.

???

←

It renders itself, but not any of its child components, deferring to the runtime (React) to do that.

---

class: has-code

# `view = fn(props, state)`

```js
> Page({user: {name: 'Benjie'}})
*{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
```

This is called a 'shallow render'; and it's one of the things that makes the virtual DOM awesome.

For example, you can test the output of `Page` **independent of the output from** `LoggedInPage`.

???

**Unit testing**: test each component, independent of the child components

---

class: has-code

# `view = fn(props, state)`

```js
> Page({user: {name: 'Benjie'}})
*{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
```

This is called a 'shallow render'; and it's one of the things that makes the virtual DOM awesome.

For example, you can test the output of `Page` independent of the output from `LoggedInPage`.

It's also a source of massive speed-ups when you have **pure components** (more on this later).

???

But basically: if you can see it's the **same component** and it has the
**same props** then there's no need to even invoke it because nothing will
change.

... Okay, so let's keep rendering down the tree. Next up is to call
**LoggedInPage** with the given props...

---

class: has-code

# `view = fn(props, state)`

```js
> Page({user: {name: 'Benjie'}})
{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
*> LoggedInPage({ children: [], user: { name: 'Benjie' } })
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
*       { component: [Function: UserName],
          props: { children: [], user: { name: 'Benjie' } } },
        '!' ] } }
```

???

Another shallow render, since this output references **UserName**. Let's keep
going...
---

class: has-code

# `view = fn(props, state)`

```js
> Page({user: {name: 'Benjie'}})
{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
> LoggedInPage({ children: [], user: { name: 'Benjie' } })
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
        { component: [Function: UserName],
          props: { children: [], user: { name: 'Benjie' } } },
        '!' ] } }
*> UserName({ children: [], user: { name: 'Benjie' } })
{ component: 'span', props: { children: [ 'Benjie' ] } }
```

???

This time there's no further components, so we're done. Moving all this to the top of the screen...
**And plugging the results into each other**
---

class: has-code

.context[

```js
> Page({user: {name: 'Benjie'}})
{ component: [Function: LoggedInPage],
  props: { children: [], user: { name: 'Benjie' } } }
> LoggedInPage({ children: [], user: { name: 'Benjie' } })
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
        { component: [Function: UserName],
          props: { children: [], user: { name: 'Benjie' } } },
        '!' ] } }
> UserName({ children: [], user: { name: 'Benjie' } })
{ component: 'span', props: { children: [ 'Benjie' ] } }
```
]

A **deep render** produces this virtual DOM tree:

```js
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
        { component: 'span', props: { children: [ 'Benjie' ] } },
        '!' ] } }
```

---

class: has-code

.context[

A deep render produces this virtual DOM tree:

```js
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
        { component: 'span', props: { children: [ 'Benjie' ] } },
        '!' ] } }
```
]

**which translates to this HTML:**

```html
<h1>Hello <span>Benjie</span>!</h1>
```

???

Don't worry if you didn't follow that 100%, we've effectively derived the
virtual DOM in about 5 minutes, so that ache in your head is perfectly
natural.

**For those of you who zoned out for all that code, time to tune back in!**

**Here's the important bit...**


---

class: has-code

# `view = fn(props, state)`

Now imagine I change the params, so  
instead of `Page({user: {name: 'Benjie'}})`,  
we do `Page({user: {name: 'Jof'}})`

---

class: has-code

# `view = fn(props, state)`

```js
// Before
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
*       { component: 'span', props: { children: [ 'Benjie' ] } },
        '!' ] } }

// After
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
*       { component: 'span', props: { children: [ 'Jof' ] } },
        '!' ] } }
```

???

At the top is the virtual DOM tree we had before.

And at the bottom is the new one...

They're almost identical, but not quite...

---

class: has-code

# `view = fn(props, state)`

```js
// Before
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
*       { component: 'span', props: { children: [ 'Benjie' ] } },
        '!' ] } }

// After
{ component: 'h1',
  props:
   { children:
      [ 'Hello ',
*       { component: 'span', props: { children: [ 'Jof' ] } },
        '!' ] } }
```

This is where React's magic comes in.

???

This is where React's magic comes in... **(PTO!)**

---

class: has-code

# `view = fn(props, state)`

Instead of naively re-rendering everything, React **diffs the Virtual
DOM** and executes only the changes necessary to transform the old
DOM state into the new one.

???

# **←**

---

class: has-code

# `view = fn(props, state)`

Instead of naively re-rendering everything, React diffs the Virtual
DOM and executes only the changes necessary to transform the old
DOM state into the new one.

And what's more, it does it **without reading the browser DOM** - so no
read-write-read-write DOM re-layout bottlenecks!


---

class: has-code

# `view = fn(props, state)`

And **this isn't limited to HTML** and the browser! Facebook have split React
into it's core logic (React) and on top of that you can build a renderer for
other things.

---

class: has-code

# `view = fn(props, state)`

And this isn't limited to HTML and the browser! Facebook have split React
into it's core logic (React) and on top of that you can build a renderer for
other things.

`react-dom` - **HTML rendering** (server and browser)

---

class: has-code

# `view = fn(props, state)`

And this isn't limited to HTML and the browser! Facebook have split React
into it's core logic (React) and on top of that you can build a renderer for
other things.

`react-dom` - HTML rendering (server and browser)

`react-native` - **iOS and Android** apps using **native views**

--

.aside[

(See [Reconciliation](http://facebook.github.io/react/docs/reconciliation.html) in their docs for how they changed an O(n<sup>3</sup>) problem to O(n))
]

???

The state of the art algorithms for generating the minimum number of operations to transform one tree into another have a complexity in the order of O(n3).

By settling on a number of heuristics and compromises, React has turned this into O(n)

---

class: middle, center, brown

# 4. But doesn't it have that weird syntax?

---

# New Syntax

Remember our `dom(component, attributes, ...children)` method from before?

--

React calls that `React.createElement(component, attributes, ...children)`.

---

# New Syntax

Instead of writing `React.createElement(component, attributes, ...children)` all over the place, we can **extend JavaScript's syntax** to be more convenient.

---


# New Syntax

Instead of writing `React.createElement(component, attributes, ...children)` all over the place, we can extend JavaScript's syntax to be more convenient.

We call this new syntax **JSX**.


---

# New Syntax

Instead of writing `React.createElement(component, attributes, ...children)` all over the place, we can extend JavaScript's syntax to be more convenient.

We call this new syntax JSX.

Using JSX is **optional** - it's just syntactic sugar.

---

# New Syntax

Instead of writing `React.createElement(component, attributes, ...children)` all over the place, we can extend JavaScript's syntax to be more convenient.

We call this new syntax JSX.

Using JSX is optional - it's just syntactic sugar.

## Let's take a look...

---

class: has-code

# JSX

```jsx
//const LoggedOutPage = () => dom('a', {href: '/login'}, 'Please log in!');
* const LoggedOutPage = () => (<a href="/login">Please log in!</a>);
```

???

I've left these examples as `dom` just so they fit on the page, mentally
replace them with `React.createElement`

---

class: has-code

# JSX

.context[
```jsx
//const LoggedOutPage = () => dom('a', {href: '/login'}, 'Please log in!');
  const LoggedOutPage = () => (<a href="/login">Please log in!</a>);
```
]

```jsx
//const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', dom(UserName, {user}), '!
* const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```

---

class: has-code

# JSX

.context[
```jsx
//const LoggedOutPage = () => dom('a', {href: '/login'}, 'Please log in!');
  const LoggedOutPage = () => (<a href="/login">Please log in!</a>);
```
```jsx
//const LoggedInPage = ({user}) => dom('h1', {}, 'Hello ', dom(UserName, {user}), '!
  const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```
]

```jsx
//const UserName = ({user}) => dom('span', null, user.name);
* const UserName = ({user}) => (<span>{user.name}</span>);
```
```jsx
//const Page = (props) => (
//  props.user
//  ? LoggedInPage(props)
//  : LoggedOutPage(props)
//);
* const Page = (props) => (
*   props.user
*   ? (<LoggedInPage user={props.user} />)
*   : (<LoggedOutPage />)
* );
```

---

class: has-code

# JSX

```jsx
const UserName = ({user}) => (<span>{user.name}</span>);
```
```jsx
const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```
```jsx
const LoggedOutPage = () => (<a href="/login">Please log in!</a>);
```
```jsx
const Page = (props) => (
  props.user
  ? (<LoggedInPage user={props.user} />)
  : (<LoggedOutPage />)
);
```

???

So here it all is, nice and tidy. The brackets are optional, but I prefer to
keep them in.

---

class: normal

## JSX vs HTML oddities:

Case matters: `onClick` not `onclick`

Some attributes are renamed to avoid clashes:  
`class` → `className`; `for` → `htmlFor`

You have to close tags (think XHTML)

Be explicit: `<table>`**`<tbody>`**`<tr><td>...`

---

class: middle, center, brown

# 5. Class vs functional components
---

class: has-code

## Class Components

So far we've dealt with **functional components**.

???

So called because they're components that are simply functions.

---

class: has-code

## Class Components

So far we've dealt with functional components.

If your component needs **state** or **lifecycle methods** then it needs to be a **class component**.

???

For example if it needs to store local data, or if it needs to do something
when it's added/removed (e.g. render Google Maps)

---

class: has-code

## Class Components

So far we've dealt with functional components.

If your component needs **state** or **lifecycle methods** then it needs to be a **class component**.


.aside[

*Or a HOC (higher order component); but let's skip over that for now...
]

---

class: has-code

## Class Components

So far we've dealt with functional components.

If your component needs **state** or **lifecycle methods** then it needs to be a **class component**.

```jsx
// Functional
const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```

---

class: has-code

## Class Components

So far we've dealt with functional components.

If your component needs **state** or **lifecycle methods** then it needs to be a **class component**.

```jsx
// Functional
const LoggedInPage = ({user}) => (<h1>Hello <UserName user={user} />!</h1>);
```
```jsx
// Class
class LoggedInPage extends React.Component {
  render() {
*   const {user} = this.props;
*   return (<h1>Hello <UserName user={user} />!</h1>);
  }
}
```
---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
* state = {currentDate: new Date()};

  updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
    this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
    const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
    return (
      <span>
        {seconds} seconds remain until {this.props.date.toISOString()}
      </span>
    );
  }
}
```

???

If render depended on the current date directly then every time we called it,
it would output different data.

Instead we store a snapshot of the current date so that every render will
return the same result until we update the date.

---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
  state = {currentDate: new Date()};

  updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
    this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
*   const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
*   return (
*     <span>
*       {seconds} seconds remain until {this.props.date.toISOString()}
*     </span>
*   );
  }
}
```

???

Now we calculate the remaining time in seconds and render it.

---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
  state = {currentDate: new Date()};

  updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
*   this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
    const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
    return (
      <span>
        {seconds} seconds remain until {this.props.date.toISOString()}
      </span>
    );
  }
}
```

???

Now the initial render is complete the HTML has been written to the browser and we can set up a timer to update our date snapshot every second.
---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
  state = {currentDate: new Date()};

* updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
    this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
    const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
    return (
      <span>
        {seconds} seconds remain until {this.props.date.toISOString()}
      </span>
    );
  }
}
```
---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
  state = {currentDate: new Date()};

  updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
    this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
*   const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
*   return (
*     <span>
*       {seconds} seconds remain until {this.props.date.toISOString()}
*     </span>
*   );
  }
}
```
---

class: has-code

## Class Components

```jsx
class Countdown extends React.Component {
  state = {currentDate: new Date()};

  updateTime = () => this.setState({currentDate: new Date()});

  componentDidMount() {
    this.timer = setInterval(this.updateTime, 1000);
  }

  componentWillUnmount() {
*   clearInterval(this.timer);
  }

  render() {
    const seconds = Math.floor((this.props.date - this.state.currentDate) / 1000);
    return (
      <span>
        {seconds} seconds remain until {this.props.date.toISOString()}
      </span>
    );
  }
}
```

???

Finally we clean up after ourselves: clearing the timer when we unmount the component.
---

class: middle, center, brown

# 6. Props and state

---

class: normal, has-code

**Props** are used to pass **external data** to components.

???

... This can be from one component to the next, or directly in at the root node.

---

class: normal, has-code

**Props** are used to pass **external data** to components.

```jsx
<UserCard
* user={{
    fullName: 'Benjie Gillam',
    id: 1,
    avatarUrl: 'https://s.gravatar.com/avatar/9b0431915359b131d88667c6b4078dc7'
  }}
* size='small'
/>
```

---

class: normal, has-code

**Props** are used to pass **external data** to components.

```jsx
<UserCard
  user={{
    fullName: 'Benjie Gillam',
    id: 1,
    avatarUrl: 'https://s.gravatar.com/avatar/9b0431915359b131d88667c6b4078dc7'
  }}
  size='small'
/>
```
```jsx
*// Components can then pass (optionally modified) props on to sub-components
function UserCard({user, size}) {
  return (
    <div className='UserCard'>
*     <Avatar url={user.avatarUrl} small={size === 'small'} />
*     <UserName user={user}></UserName>
    </div>
  );
}
```


---

class: normal

## **State**

---

class: normal

## State

It's generally **best to be state-less**; state makes bugs a lot harder to track down.

---

class: normal

## State

It's generally best to be state-less; state makes bugs a lot harder to track down.

**Local data** (per-component) is stored to `this.state`, e.g. `this.state.firstName`.

---

class: normal

## State

It's generally best to be state-less; state makes bugs a lot harder to track down.

Local data (per-component) is stored to `this.state`, e.g. `this.state.firstName`.

When you change `this.state` (by calling `this.setState`), React **automatically re-renders**.


---

class: middle, center, brown

# 7. Events / controlled components

---

class: middle, center

**Events** are how you **manipulate your data**

<div style='visibility: hidden'>
<img width="80%" src="images/one-way.svg" />
</div>

---

class: middle, center

**Events** are how you **manipulate your data**

<div>
<img width="80%" src="images/one-way.svg" />
</div>

---

class: has-code

```jsx
*const TodoItem = ({text, onTrashClick}) => (
  <div className='TodoItem'>
    <div className='TodoItem__text'>{text}</div>
*   <div className='TodoItem__trash' onClick={onTrashClick}>X</div>
  </div>
);
```

---

class: has-code

```jsx
const TodoItem = ({text, onTrashClick}) => (
  <div className='TodoItem'>
    <div className='TodoItem__text'>{text}</div>
    <div className='TodoItem__trash' onClick={onTrashClick}>X</div>
  </div>
);
*const TodoList = ({items, onDeleteItem}) => (
  <div className='TodoList'>
    {items.map(
      ({text, id}) => (
        <TodoItem
          key={id}
          text={text}
*         onTrashClick={(e) => onDeleteItem(id)}
        />
      )
    )}
  </div>
);
```
---

class: has-code

```jsx
const TodoItem = ({text, onTrashClick}) => (
  // ...  <div ...
  onClick={onTrashClick}
  // ...  >X</div> ...
);
const TodoList = ({items, onDeleteItem}) => (
  // ...  <TodoItem ...
          onTrashClick={(e) => onDeleteItem(id)}
  // ...  /> ...
);
class TodoApp extends React.Component {
  state = {items: getInitialItems()}

* handleDelete = (id) => {
*   this.setState({items: this.state.items.filter(item => item.id !== id)});
  }

  render() {
    return (
      <div className='TodoApp'>
*       <TodoList items={this.state.items} onDeleteItem={this.handleDelete} />
      </div>
    );
  }
}
```
---

class: middle, center

## Controlled Components

To avoid storing implicit state in the DOM.
---

class: has-code

```jsx
class TodoApp extends React.Component {
  state = {items: getInitialItems(),
*   nextItemText: ''};
  handleDelete = (id) => {...}

  render() {
    return (
      <div className='TodoApp'>
        <TodoList items={this.state.items} onDeleteItem={this.handleDelete} />
*       <input
*         value={this.state.nextItemText}
*         onChange={e => this.setState({nextItemText: e.target.value})}
*       />
      </div>
    );
  }
}
```
---

class: has-code

```jsx
class TodoApp extends React.Component {
  state = {items: getInitialItems(),
    nextItemText: ''};
  handleDelete = (id) => {...}
  handleKeyPress = (e) => {
*   if (e.key === 'Enter') {
*     this.setState({
*       items: [].concat(this.state.items,
*         {id: newId(), text: this.state.nextItemText}),
*       nextItemText: '',
      });
    }
  },
  render() {
    return (
      <div className='TodoApp'>
        <TodoList items={this.state.items} onDeleteItem={this.handleDelete} />
        <input
*         onKeyPress={this.handleKeyPress}
          value={this.state.nextItemText}
          onChange={e => this.setState({nextItemText: e.target.value})}
        />
      </div>
    );
  }
}
```
---

class: middle, center, brown

# 8. Immutability

An immutable object is an object whose state cannot be modified after it is created
---


## Immutability

A component that only uses immutable data is called a **pure component**.

---


## Immutability

A component that only uses immutable data is called a pure component.

By only using immutable data, we can **very quickly** check which props have changed.

---


## Immutability

A component that only uses immutable data is called a pure component.

By only using immutable data, we can very quickly check which props have changed.

If none have changed we can **bypass rendering** and reuse the last virtual DOM subtree.

---


## Immutability

A component that only uses immutable data is called a pure component.

By only using immutable data, we can very quickly check which props have changed.

If none have changed we can bypass rendering and reuse the last virtual DOM subtree.

This can happen for **every component**!

<!--

class: has-code

## Immutability

```jsx
class FibonacciNumber extends React.PureComponent {
  fibonacci(n) {
    if (n < 1) return 0;
    if (n == 1) return 1;
    return this.fibonacci(n - 1) + this.fibonacci(n - 2);
  }
  render() {
    return (
      <span>{this.fibonacci(this.props.n)}
    );
  }
}
```
-->
---

class: middle, center, brown

# 9. Hot reloading
---

class: hot-reload, contain


---

class: middle, center, brown

# 10. AWESOME!

## So should we rebuild everything in React?

<p style="visibility: hidden">No, not necessarily</p>

---

class: middle, center, brown

# 10. AWESOME!

## So should we rebuild everything in React?

No, not necessarily

---

class: center

# **React is a library**

---

class: center

# React is a library

You can **embed React** into other things.

---

class: center

# React is a library

You can embed React into other things.

You can **embed other things into React**.

---

class: center

# React is a library

You can embed React into other things.

You can embed other things into React.

You can **migrate to React bit-by-bit** without having to rebuild everything!

---

class: center

# React is a library

You can embed React into other things.

You can embed other things into React.

You can migrate to React bit-by-bit without having to rebuild everything!

The React API is really small, so very **quick to learn**.

---
class: middle, center, brown

# Recap

---

class: normal

## Recap

One-way data flow

Virtual DOM

Reusable components

Good habits, no unnecessary re-layout

Can migrate bit-by-bit

Small API


---

class: normal, center, middle

## SO YOU'RE CONVERTED!

Where to next?

https://facebook.github.io/react/docs

`npm install create-react-app -g`

https://egghead.io/technologies/react

https://getstorybook.io/


---

class: hot-storybook, contain

---

class: postgraphql-is, cover, middle, center

# Thank you!

### Any questions?

.slidesLocation[

[benjie.github.io/react-technical-intro/](https://benjie.github.io/react-technical-intro/)
]

--></script>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        source: (document.getElementById("source").innerHTML).replace(/^<!--|-->$/g, ""),
        slideNumberFormat: function (current, total) { return null },
        ratio: '4:3',
        highlightLines: true,
        highlightSpans: false // We need ES6 backticks
      });
      var HomeView = Backbone.View.extend({
        template: _.template('<h1>Hello World!</h1>' +
          '<p>Random number: <span><%- number %></span> (click for another)</p>' +
          '<textarea>Notes...</textarea>'),

        events: {
          'click p': 'render',
          'keydown textarea': 'stopPropagation',
          'keypress textarea': 'stopPropagation',
        },

        stopPropagation: function(e) {
          e.stopPropagation();
        },

        randomNumber: function() {
          return Math.floor(Math.random() * 100) + 1;
        },

        render: function() {
          this.$el.html(this.template({
            number: this.randomNumber()
          }));
        }
      });
      var HomeView2 = Backbone.View.extend({
        template: _.template('<h1>Hello World!</h1>' +
          '<p class="_button">Random number: ' +
            '<span><%- number %></span> (click for another)' +
          '</p>' +
          '<textarea>Notes...</textarea>'),
        events: {
          'click ._button': 'newNumber',
          'keydown textarea': 'stopPropagation',
          'keypress textarea': 'stopPropagation',
        },
        stopPropagation: function(e) {
          e.stopPropagation();
        },
        randomNumber: function() {
          return Math.floor(Math.random() * 100) + 1;
        },
        newNumber: function(e) {
          this.$("._button span").html(this.randomNumber());
        },
        render: function() {
          this.$el.html(this.template({
            number: this.randomNumber()
          }));
        }
      });
      const backbone1 = new HomeView();
      $("#backbone1").append(backbone1.el);
      backbone1.render();
      const backbone2 = new HomeView2();
      $("#backbone2").append(backbone2.el);
      backbone2.render();
      const randomNumber = function() {return Math.floor(Math.random() * 100) + 1;}

      const stopPropagation = (e) => e.stopPropagation();

      const HomeView3 = React.createClass({
        getInitialState: function() {
          return {randomNumber: randomNumber()};
        },

        newNumber: function() {
          this.setState({randomNumber: randomNumber()});
        },

        render: function() {
          return (
            React.createElement('div', null,
              React.createElement('h1', null, 'Hello World!'),
              React.createElement('p', {onClick: this.newNumber.bind(this)},
                'Random number: ', this.state.randomNumber, ' (click for another)'
              ),
              React.createElement('textarea', {onKeyPress: stopPropagation, onKeyDown: stopPropagation}, 'Notes...')
            )
          );
        }
      });
      ReactDOM.render(React.createElement(HomeView3), $("#react1")[0]);
    </script>
    <script>
      document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')
    </script>
  </body>
</html>
